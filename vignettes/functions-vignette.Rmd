---
title: "kinfitr Function Examples"
author: "Granville J Matheson"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{kinfitr Function Examples}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.width = 8, fig.height = 6)
```

\newpage

# Background

Reproducible research involves analysis and reporting of the data from raw data to final outcomes in one unified framework.  Given the data, another researcher should be able to run it through the same analysis, and see each step of the analysis and check the robustness of the findings as they wish.  This also means that the addition of extra data, or omission of problematic data, or changes to the way that data should be processed should be straightforward to implement without the need of error-prone manual entering and reporting of data.  In this way, research is made more transparent, errors should be rarer and easier to diagnose, and the analysis itself is also made easier in the long run, with its requiring little to no extra work as data sets increase, or errors in the raw data are discovered.

R is the ideal option for performing reproducible research as its primary IDE, RStudio, comes prepackaged with R Markdown and knitr, which is specifically designed for reproducible research and generating reproducible reports. Furthermore, as opposed to MATLAB, it is free which means that the data analysis can be run by anyone and not only those who pay for the software.  It is also a language designed for statistical analysis, meaning that it is ideally suited to the statistical analysis and presentation.  Finally, there are powerful tools within R for performing the fitting procedures required for effective kinetic modelling.

Software available at present for TAC extraction and kinetic analysis include commercial products, MIAKAT (which is open-source, but still requires MATLAB which is not freeware), and various custom-built tools within groups, most often built in MATLAB.  Statistical modelling and presentation are sometimes performed in MATLAB, but are usually performed using various statistical and graphical programs.

All the processes up until TAC extraction require large raw data files to be shared and to be reproducible, which are often complicated not only to store, but also to share as they contain sensitive patient information in the form of an image, which is theoretically difficult to fully anonymise and therefore ethically problematic.  TAC extraction is also a process which can be performed in many different software packages as this does not differ between PET and fMRI, including, for example, NiPy in Python, which is also a free software package.  Storage and sharing of TACs is more convenient as this data is in the form of a text document containing one-dimensional time series data.  This therefore, in the opinion of the author, represents the ideal step of the image analysis pipeline to begin a reproducible analysis which can be shared in full.  This can also be kept for documentation purposes in the interests of data transparency.

For these reasons, and to enhance my own knowledge of popular kinetic modelling procedures, I have written a kinetic modelling R package which can analyse and plot TAC data using several popular kinetic models, while easily accepting input data for each function in as raw a form as possible without requiring complex data structures.  Furthermore, each process stores not only the parameters, but also the fit itself, the fitted values, all of the input data, and has straightforward tools for plotting the model to perform quality control.


```{r source stuff 1, echo=FALSE, warning=F, message=F}
datafolder = '../../kinfitr_functions'
```

```{r}
# Loading packages
library(kinfitr)

library(knitr)
library(pander)
library(broom)
```


\newpage

***

# Reference Region Models

## Data

```{r load data ref, echo=FALSE}
tacdata <- read.csv(paste0(datafolder, '/subj1_tacs.csv'))
```

```{r refmodel vectors}
times = tacdata$Time/60
reftac <- tacdata$RefCBL
roitac <- tacdata$FSLSSTR
weights <- tacdata$Weights
```

First all the data is loaded (unshown).  This data includes:

* Times 
    + Middle of each frame in minutes
* Reference TAC 
    + Cerebellar Grey Matter
* ROI TAC 
    + Striatum
* Weights
    + Range: 0:1

\newpage

This data is plotted below:

```{r refdata, fig.width = 4, fig.height = 6.5, fig.cap='Reference Region Model Data'}
par(mfrow=c(3,1))

plot(times, reftac)
plot(times, roitac)
plot(times, weights)
```


\newpage

## SRTM

$$C(t) = R_{1}C_{R}(t)+(k_{2}-\frac{R_{1}k_{2}}{1+BP_{ND}})C_{R}(t)\otimes e^{-\frac{k_{2}}{1+BP_{ND}}t}$$

SRTM requires input of the times, reftac and roitac.  Weights are optional.

```{r srtm}
srtmout <- srtm(times, reftac, roitac, weights)
```

### Parameters

```{r srtm par, results = "asis"}
pandoc.table(srtmout$par, digits = 3)
```

\newpage

### Plot

The output object can be used to visualise the fit:

```{r srtm plotfit, fig.cap='SRTM Fit Check'}
plot_srtmfit(srtmout)
```

\newpage

... and the residuals:

```{r srtm plotres, fig.cap='SRTM Residuals'}
plot_residuals(srtmout)
```

### Output structure:

Included in the output are all the parameters, the parameters of the fitting functions, the fits themselves and the raw data.

```{r srtm str, results = "asis"}
pandoc.table(summary(srtmout))
```

This means that the fit can be easily evaluated and compared with other fits:

```{r srtm fitstructure, results = "asis"}
pandoc.table(glance(srtmout$fit), digits=3)
```






\newpage

***


## Non-Invasive Logan Plot

refLogan requires input of the times, reftac, roitac and k2prime.  Weights are optional.

k2prime can be obtained from the srtm fit:

```{r srtm k2prime}
k2prime = srtmout$par$k2 / srtmout$par$R1
k2prime
```

First, we wish to ascertain what a suitable t* value would be.  For this, we use TACs from a low-, medium- and high-binding region.

```{r refLogan tstar, error=F, warning=F}
taclow = tacdata$FSLSFC    # Frontal Cortex 
tacmed = tacdata$fslLST    # Limbic Striatum
tachigh = tacdata$fslAST   # Associative Striatum

refLogan_tstar(times, reftac, taclow, tacmed, tachigh, k2prime = k2prime, 'demonstration')
```

\newpage
![refLogan tstar finder](demonstration_refLogan.jpeg){width=600px}
\newpage

Using this information, we see that we should probably use 9 included frames for the fit.

```{r refLogan}
refloganout <- refLogan(times, reftac, roitac, k2prime, 
                        tstarIncludedFrames = 9, weights=weights)
```

### Parameters

```{r reflogan par, results = "asis"}
pandoc.table(refloganout$par)
```

### Plot

The output object can be used to visualise the fit:

```{r reflogan plotfit, warning=F, fig.cap='RefLogan Fit Check'}
plot_refLoganfit(refloganout)
```

\newpage

... and the residuals:

```{r reflogan plotres, fig.cap='RefLogan Residuals'}
plot_residuals(refloganout)
```


### Output structure:

Included in the output are all the parameters, the parameters of the fitting functions, the fits themselves and the raw data.

```{r reflogan str, results = "asis"}
pandoc.table(summary(refloganout))
```

This means that the fit can be easily evaluated and compared with other fits:

```{r reflogan fitstructure, results = "asis"}
pandoc.table(glance(refloganout$fit), digits = 3)
```






\newpage

***

## MRTM1

MRTM1 requires input of the times, reftac and roitac.  Weights are optional.

First, we wish to ascertain what a suitable t* value would be.  For this, we use TACs from a low-, medium- and high-binding region.

```{r mrtm1 tstar, error=F, warning=F, eval=F}
mrtm1_tstar(times, reftac, taclow, tacmed, tachigh, 'demonstration')
```

Using this information (unshown), we see that we should probably use all 14 frames for the fit.

```{r mrtm1}
mrtm1out <- mrtm1(times, reftac, roitac, tstarIncludedFrames = 14, weights=weights)
```

### Parameters

```{r mrtm1 par, results = "asis"}
pandoc.table(mrtm1out$par, digits = 3)
```

### Plot

The output object can be used to visualise the fit:

```{r mrtm1 plotfit, warning=F, fig.cap='MRTM1 Fit Check'}
plot_mrtm1fit(mrtm1out)
```

\newpage

... and the residuals:

```{r mrtm1 plotres, fig.cap='MRTM1 Residuals'}
plot_residuals(mrtm1out)
```


### Output structure:

Included in the output are all the parameters, the parameters of the fitting functions, the fits themselves and the raw data.

```{r mrtm1 str, results = "asis"}
pandoc.table(summary(mrtm1out))
```

This means that the fit can be easily evaluated and compared with other fits:

```{r mrtm1 fitstructure, results = "asis"}
pandoc.table(glance(mrtm1out$fit), digits = 3)
```




\newpage

***

## MRTM2

MRTM2 requires input of the times, reftac, roitac and k2prime.  Weights are optional.

k2prime can be obtained from the mrtm1 fit:

```{r mrtm k2prime}
k2prime = mrtm1out$par$k2prime
k2prime
```

First, we wish to ascertain what a suitable t* value would be.  For this, we use TACs from a low-, medium- and high-binding region.

```{r mrtm2 tstar, error=F, warning=F, eval=F}
mrtm2_tstar(times, reftac, taclow, tacmed, tachigh, k2prime=k2prime, 'demonstration')
```

Using this information (unshown), we see that we should probably use all 14 frames for the fit.

```{r mrtm2}
mrtm2out <- mrtm2(times, reftac, roitac, k2prime = k2prime, 
                  tstarIncludedFrames = 14, weights=weights)
```

### Parameters

```{r mrtm2 par, results = "asis"}
pandoc.table(mrtm2out$par)
```


### Plot

The output object can be used to visualise the fit:

```{r mrtm2 plotfit, warning=F, fig.cap='MRTM2 Fit Check'}
plot_mrtm2fit(mrtm2out)
```

\newpage

... and the residuals:

```{r mrtm2 plotres, fig.cap='MRTM2 Residuals'}
plot_residuals(mrtm2out)
```


### Output structure:

Included in the output are all the parameters, the parameters of the fitting functions, the fits themselves and the raw data.

```{r mrtm2 str, results = "asis"}
pandoc.table(summary(mrtm2out))
```


This means that the fit can be easily evaluated and compared with other fits:

```{r mrtm2 fitstructure, results = "asis"}
pandoc.table(glance(mrtm2out$fit), digits = 3)
```


\newpage

***


## Non-Invasive Multilinear Logan Plot

$$\int _{0} ^{t} C_{T} (\tau) d\tau = DVR\Bigg(\int _{0} ^{t} C_{T}' (\tau) d\tau+\frac{C_{T}'(t)}{k2'}\Bigg)-bC_{T}(t)$$

refmlLogan is the kinetic model used in WAPI, which is detailed in Turkheimer's 2003 IEEE paper.  This model requires input of the times, reftac and roitac and k2prime.  Weights are optional.

First, we wish to ascertain what a suitable t* value would be.  For this, we use TACs from a low-, medium- and high-binding region.

```{r refmlLogan tstar, error=F, warning=F, eval=F}
taclow = tacdata$FSLSFC    # Frontal Cortex 
tacmed = tacdata$fslLST    # Limbic Striatum
tachigh = tacdata$fslAST   # Associative Striatum

refmlLogan_tstar(times, reftac, taclow, tacmed, tachigh, k2prime, 'demonstration')
```

Using this information (unshown), we see that we should probably use 9 included frames for the fit.  We shall use 6.

```{r refmlLogan}
refmlloganout <- refmlLogan(times, reftac, roitac, k2prime,
                        tstarIncludedFrames = 9, weights=weights)
```

### Parameters

```{r refmllogan par, results = "asis"}
pandoc.table(refmlloganout$par, digits = 3)
```

### Plot

The output object can be used to visualise the fit:

```{r refmllogan plotfit, warning=F, fig.cap='RefmlLogan Fit Check'}
plot_refmlLoganfit(refmlloganout)
```

\newpage

... and the residuals:

```{r refmllogan plotres, fig.cap='RefLogan Residuals'}
plot_residuals(refmlloganout)
```


### Output structure:

Included in the output are all the parameters, the parameters of the fitting functions, the fits themselves and the raw data.

```{r refmllogan str, results = "asis"}
pandoc.table(summary(refmlloganout))
```

This means that the fit can be easily evaluated and compared with other fits:

```{r refmllogan fitstructure, results = "asis"}
pandoc.table(glance(refmlloganout$fit), digits = 3)
```






\newpage

***



## Patlak Reference Tissue Model

refPatlak requires input of the times, reftac and roitac.  Weights are optional.

First, we wish to ascertain what a suitable t* value would be.  For this, we use TACs from a low-, medium- and high-binding region.

```{r refPatlak tstar, error=F, warning=F, eval=F}
taclow = tacdata$FSLSFC    # Frontal Cortex 
tacmed = tacdata$fslLST    # Limbic Striatum
tachigh = tacdata$fslAST   # Associative Striatum
refPatlak_tstar(times, reftac, taclow, tacmed, tachigh, 'demonstration')
```


Since this is actually a reversible tracer, we shouldn't really be using refPatlak at all, but we can use four frames to test it out (unshown).

```{r refPatlak}
refpatlakout <- refPatlak(times, reftac, roitac, 
                        tstarIncludedFrames = 4, weights=weights)
```

### Parameters

```{r refPatlak par, results = "asis"}
pandoc.table(refpatlakout$par, digits=4)
```

### Plot

The output object can be used to visualise the fit:

```{r refPatlak plotfit, warning=F, fig.cap='RefPatlak Fit Check'}
plot_refPatlakfit(refpatlakout)
```

\newpage

... and the residuals:

```{r refPatlak plotres, fig.cap='RefPatlak Residuals'}
plot_residuals(refpatlakout)
```


### Output structure:

Included in the output are all the parameters, the parameters of the fitting functions, the fits themselves and the raw data.

```{r refPatlak str, results = "asis"}
pandoc.table(summary(refpatlakout))
```

This means that the fit can be easily evaluated and compared with other fits:

```{r refPatlak fitstructure, results = "asis"}
pandoc.table(glance(refpatlakout$fit), digits = 3)
```




\newpage

***

# Models Requiring Arterial Input

## Data

```{r load stuff 2, echo=FALSE, warning=F, message=FALSE}
 roistats <- R.matlab::readMat(paste0(datafolder, '/pbrdata/subj2_dynpet1_roistats.mat'))
```

```{r load stuff 2 part 2, echo=FALSE, warning=F, message=FALSE}
 inptacdata <- as.data.frame(unlist(roistats$stats[, ,1]$greymasked[3][[1]]))
 inproinames = unlist(roistats$stats[, ,1]$roinames)
 inproinames = gsub('#', 'gm', inproinames)
 names(inptacdata) <-  inproinames
 inptacdata$times <- as.numeric(roistats$stats[, ,1]$times[, , 1]$center)
 
 weights <- as.numeric(unlist(read.table(paste0(datafolder, '/pbrdata/Plasma_blood_parent_fraction_weights/PET1/Weights_1/subj2_1_weights.txt'), header=F)))
 
blooddata  <- read.table(paste0(datafolder, '/pbrdata/Plasma_blood_parent_fraction_weights/PET1/Blood_1/subj2_PET1_L312_T5400_blood.txt'), header=T)
plasmadata <- read.table(paste0(datafolder, '/pbrdata/Plasma_blood_parent_fraction_weights/PET1/Plasma_1/subj2_PET1_L312_T5400_plasma.txt'), header=T)
parentdata <- read.table(paste0(datafolder, '/pbrdata/Plasma_blood_parent_fraction_weights/PET1/Parent_frac_1/subj2_1_parent_fraction.txt'), header=T, skip=1)
names(parentdata) <- c('Times', 'Fraction')
 
 tac <- inptacdata$GM
 t_tac <- inptacdata$times/60
```


First all the data is loaded (unshown).  This data includes:

* TAC Times 
    + Middle of each frame in minutes
* ROI TAC 
    + Grey Matter
* Weights
    + Range: 0:1
* Blood TACs
* Plasma TACs
* Blood Times
    + Minutes
* Parent Fraction
* The Delay (can be fitted, or inputted)

The data is plotted below:

```{r compartmental data, fig.width = 4, fig.height = 9, fig.align='center', fig.cap='Compartmental Model Data', fig.width = 7, fig.height = 7}
par(mfrow=c(2,2))

plot(t_tac, tac)
plot(blooddata$Time.sec., blooddata$Cbl.nCi.cc., xlab = 'Time (sec)', ylab = 'Cb')
plot(plasmadata$Time.sec., plasmadata$Cpl.nCi.cc., xlab = 'Time (sec)', ylab = 'Cp')
plot(parentdata$Times, parentdata$Fraction, xlab = 'Time (sec)', ylab = 'Parent Fraction')
```

\newpage

First, we must organise the blood data and put it together.  This function can also accept parent-fraction-corrected plasma data too.

```{r blood input, fig.cap='Input Data', warning=F}
input <- blood_interp(t_blood = blooddata$Time.sec./60, 
                      blood = blooddata$Cbl.nCi.cc.,
                      t_plasma = plasmadata$Time.sec./60, 
                      plasma = plasmadata$Cpl.nCi.cc.,
                      t_parentfrac = parentdata$Times/60,
                      parentfrac = parentdata$Fraction)
```


## One-Tissue Compartment Model

1TCM requires input of the TAC times, TAC and input.  Weights are optional.  The time shift of the input function and vB are also optional.  If they are not included, then the function will fit them.

```{r 1tcm}
onetcmout <- onetcm(t_tac, tac, input, weights=weights)
```

### Parameters

```{r onetcm par, results = "asis"}
pandoc.table(onetcmout$par, digits = 3)
```


\newpage

### Input Delay

The inpshift is the fitted delay.  We can visualise the matching of the two curves without any time shifting (i.e. as they are in the same time scale):

```{r delay plot before, fig.cap='Delay Check Before', warning=F}
plot_inptac_timings(t_tac, tac, input, inpshift = 0)
```

The timing of these two clearly do not match.  Now we can visualise the fit with the time shifting fitted by the one tissue compartment model: in this case, the delay is negative, which means that the TAC was shifted to be a little bit later.

\newpage

```{r delay plot after, fig.cap='Delay Check After', warning=F}
plot_inptac_timings(t_tac, tac, input, inpshift = onetcmout$par$inpshift)
```

This parameter has clearly performed a good job in fitting the timing of the two curves to one another.

\newpage

### Plot

The output object can be used to visualise the model fit:

```{r onetcm plotfit, fig.cap='1TCM Fit Check'}
plot_1tcmfit(onetcmout)
```

\newpage

... and the residuals:

```{r onetcm plotres, fig.cap='1TCM Residuals', warning=F}
plot_residuals(onetcmout)
```


### Output structure:

Included in the output are all the parameters, the parameters of the fitting functions, the fits themselves and the raw data.

```{r onetcm str, results = "asis"}
pandoc.table(summary(onetcmout))
```

This means that the fit can be easily evaluated and compared with other fits:

```{r onetcm fitstructure, results = "asis"}
pandoc.table(glance(onetcmout$fit), digits=3)
```






\newpage

***


## Two-Tissue Compartment Model

2TCM requires input of the TAC times, TAC and input.  Weights are optional.  The time shift of the input function and vB are also optional.  If they are not included, then the function will fit them.  In this case, we can use the delay from the 1tcm for the 2tcm fit, and it will not be fitted.

```{r 2tcm}
twotcmout <- twotcm(t_tac, tac, input, weights=weights, inpshift = onetcmout$par$inpshift)
```

### Parameters

```{r twotcm par, results = "asis"}
pandoc.table(twotcmout$par, digits = 3)
```


\newpage

### Plot

The output object can be used to visualise the model fit:

```{r twotcm plotfit, fig.cap='2TCM Fit Check'}
plot_2tcmfit(twotcmout)
```


\newpage

... and the residuals:

```{r twotcm plotres, fig.cap='2TCM Residuals', warning=F}
plot_residuals(twotcmout)
```


### Output structure:

Included in the output are all the parameters, the parameters of the fitting functions, the fits themselves and the raw data.

```{r twotcm str, results = "asis"}
pandoc.table(summary(twotcmout))
```

This means that the fit can be easily evaluated and compared with other fits:

```{r twotcm fitstructure, results = "asis"}
pandoc.table(glance(twotcmout$fit), digits=3)
```






\newpage

***


## Logan Plot

The Logan Plot method requires input of the TAC times, TAC and input.  Weights are optional.  The time shift of the input function and vB are also optional.  If they are not included, then they will be set to zero.  For the input delay, we can use the delay from the 1tcm fit.  If vB is included, it will be corrected for before the parameter estimation using the following formula:  

$$ C_{T}(t) = \frac{C_{Measured}(t) - vB\times C_{B}(t)}{1-vB} $$

First, we wish to ascertain what a suitable t* value would be.  For this, we use TACs from a low-, medium- and high-binding region.

```{r logan tstar, error=F, warning=F, eval=F}
lowroi = inptacdata$PUT
medroi = inptacdata$GM
highroi = inptacdata$gmCER

Logan_tstar(t_tac, lowroi, medroi, highroi, input, filename='demonstration', 
            inpshift = onetcmout$par$inpshift, vB = 0.05, gridbreaks=4)
```

Using this information (unshown), we see that we should probably use 10 frames for the fit.

```{r logan}
loganout <- Loganplot(t_tac, tac, input, 10, weights, inpshift = onetcmout$par$inpshift, vB=0.05)
```

### Parameters

```{r logan par, results = "asis"}
pandoc.table(loganout$par, digits=3)
```


\newpage

### Plot

The output object can be used to visualise the model fit:

```{r logan plotfit, fig.cap='Logan Plot Fit Check', warning=F}
plot_Loganfit(loganout)
```


\newpage

... and the residuals:

```{r logan plotres, fig.cap='Logan Plot Residuals', warning=F}
plot_residuals(loganout)
```


### Output structure:

Included in the output are all the parameters, the parameters of the fitting functions, the fits themselves and the raw data.

```{r logan str, results = "asis"}
pandoc.table(summary(loganout))
```


This means that the fit can be easily evaluated and compared with other fits:

```{r logan fitstructure, results = "asis"}
pandoc.table(glance(loganout$fit), digits=3)
```






\newpage

***


## MA1

The MA1 method requires input of the TAC times, TAC and input.  Weights are optional.  The time shift of the input function is also optional.  If it is not included, then it will be set to zero.

First, we wish to ascertain what a suitable t* value would be.  For this, we use TACs from a low-, medium- and high-binding region.

```{r ma1 tstar, error=F, warning=F}
lowroi = inptacdata$PUT
medroi = inptacdata$GM
highroi = inptacdata$gmCER

ma1_tstar(t_tac, lowroi, medroi, highroi, input, filename='demonstration', 
          inpshift = onetcmout$par$inpshift, gridbreaks=4)
```
\newpage
![MA1 tstar finder](demonstration_MA1.jpeg){width=600px}
\newpage


Using this information, we see that we should probably use very few frames for the fit: 11 seems reasonably good and reasonably stable.

```{r ma1}
ma1out <- ma1(t_tac, tac, input, 11, weights, inpshift = onetcmout$par$inpshift)
```

### Parameters

```{r ma1 par, results = "asis"}
pandoc.table(ma1out$par, digits=3)
```


\newpage

### Plot

The output object can be used to visualise the model fit:

```{r ma1 plotfit, fig.cap='MA1 Plot Fit Check', warning=F}
plot_ma1fit(ma1out)
```


\newpage

... and the residuals:

```{r ma1 plotres, fig.cap='MA1 Plot Residuals', warning=F}
plot_residuals(ma1out)
```


### Output structure:

Included in the output are all the parameters, the parameters of the fitting functions, the fits themselves and the raw data.

```{r ma1 str, results = "asis"}
pandoc.table(summary(ma1out))
```


This means that the fit can be easily evaluated and compared with other fits:

```{r ma1 fitstructure, results = "asis"}
pandoc.table(glance(ma1out$fit), digits=3)
```









\newpage

***


## MA2

The MA2 method requires input of the TAC times, TAC and input.  Weights are optional.  The time shift of the input function is also optional.  If it is not included, then it will be set to zero.

```{r ma2}
ma2out <- ma2(t_tac, tac, input, weights, inpshift = onetcmout$par$inpshift)
```

### Parameters

```{r ma2 par, results = "asis"}
pandoc.table(ma2out$par, digits = 3)
```

One can also calculate the rate constants from the fit terms.  The article provides a formula for calculation of V~S~, but they left out a number though for which term to use (this error is also on the PMOD page, which simply displays an image of the formula from the article).  I believe I have chosen the correct one, but this might not be the case.  V~ND~ can be calculated by subtracting V~s~ from V~T~.  


\newpage

### Plot

The output object can be used to visualise the model fit:

```{r ma2 plotfit, fig.cap='MA2 Plot Fit Check', warning=F}
plot_ma2fit(ma2out)
```


\newpage

... and the residuals:

```{r ma2 plotres, fig.cap='MA2 Plot Residuals', warning=F}
plot_residuals(ma2out)
```


### Output structure:

Included in the output are all the parameters, the parameters of the fitting functions, the fits themselves and the raw data.

```{r ma2 str, results = "asis"}
pandoc.table(summary(ma2out))
```


This means that the fit can be easily evaluated and compared with other fits:

```{r ma2 fitstructure, results = "asis"}
pandoc.table(glance(ma2out$fit), digits=3)
```





\newpage

***




## Multilinear Logan Plot

$$\int _{0} ^{t} C_{T} (\tau) d\tau = V_{T}\int _{0} ^{t} C_{P} (\tau) d\tau-\frac{1}{K_{2}}C_{T}(t)$$

The multilinear Logan Plot is the kinetic model used in WAPI, which is detailed in Turkheimer's 2003 IEEE paper.  This model requires input of the TAC times, TAC and input.  Weights are optional.  The time shift of the input function is also optional, and if it is not included, it will be set to zero.

First, we wish to ascertain what a suitable t* value would be.  For this, we use TACs from a low-, medium- and high-binding region.

```{r mllogan tstar, error=F, warning=F, eval=F}
lowroi = inptacdata$PUT
medroi = inptacdata$GM
highroi = inptacdata$gmCER

mlLogan_tstar(t_tac, lowroi, medroi, highroi, input, filename='demonstration', 
            inpshift = onetcmout$par$inpshift, gridbreaks=4)
```

Using this information (unshown), we see that we should probably use 10 frames for the fit.

```{r mllogan}
mlloganout <- mlLoganplot(t_tac, tac, input, 10, weights, inpshift = onetcmout$par$inpshift)
```

### Parameters

```{r mllogan par, results = "asis"}
pandoc.table(mlloganout$par, digits=3)
```


\newpage

### Plot

The output object can be used to visualise the model fit:

```{r mllogan plotfit, fig.cap='mlLogan Plot Fit Check', warning=F}
plot_mlLoganfit(mlloganout)
```


\newpage

... and the residuals:

```{r mllogan plotres, fig.cap='mlLogan Plot Residuals', warning=F}
plot_residuals(mlloganout)
```


### Output structure:

Included in the output are all the parameters, the parameters of the fitting functions, the fits themselves and the raw data.

```{r mllogan str, results = "asis"}
pandoc.table(summary(mlloganout))
```


This means that the fit can be easily evaluated and compared with other fits:

```{r mllogan fitstructure, results = "asis"}
pandoc.table(glance(mlloganout$fit), digits=3)
```






\newpage

***



## Patlak Plot

The Patlak Plot method requires input of the TAC times, TAC and input.  Weights are optional.  The time shift of the input function is also optional.  If it is not included, then it will be set to zero.  For the input delay, we can use the delay from the 1tcm fit.

First, we wish to ascertain what a suitable t* value would be.  For this, we use TACs from a low-, medium- and high-binding region.

```{r patlak tstar, error=F, warning=F, eval=F}
Patlak_tstar(t_tac, lowroi, medroi, highroi, input, filename='demonstration', 
            inpshift = onetcmout$par$inpshift, gridbreaks=4)
```

Since this is actually a reversible tracer, we shouldn't really be using the Patlak Plot at all, but we can use nine frames to test it out (unshown).

```{r patlak}
patlakout <- Patlakplot(t_tac, tac, input, 9, weights, inpshift = onetcmout$par$inpshift)
```

### Parameters

```{r patlak par, results = "asis"}
pandoc.table(patlakout$par, digits=3)
```


\newpage

### Plot

The output object can be used to visualise the model fit:

```{r patlak plotfit, fig.cap='Patlak Plot Fit Check', warning=F}
plot_Patlakfit(patlakout)
```


\newpage

... and the residuals:

```{r patlak plotres, fig.cap='Patlak Plot Residuals', warning=F}
plot_residuals(patlakout)
```


### Output structure:

Included in the output are all the parameters, the parameters of the fitting functions, the fits themselves and the raw data.

```{r patlak str, results = "asis"}
pandoc.table(summary(patlakout))
```


This means that the fit can be easily evaluated and compared with other fits:

```{r patlak fitstructure, results = "asis"}
pandoc.table(glance(patlakout$fit), digits=3)
```






\newpage

***



# Other Models

## SIME

The SIME method requires input of the TAC times, several TACs, input and a grid of V~ND~ values.  Weights are optional.  ROI sizes can optionally be included to weight the contributions of the different ROIs.  The time shift of the input function and vB are also optional.  If they are not included, they will be set to 0 and 0.05 respectively.

```{r SIME}
tacdf <- data.frame(GM = inptacdata$GM, 
                    ACC = inptacdata$gmACC, 
                    CER = inptacdata$gmCER, 
                    PUT = inptacdata$PUT)

Vndgrid <- seq(from=0, to=4, by=0.1)

SIMEout <-  SIME(t_tac, tacdf, input, Vndgrid, weights = weights, 
    inpshift = onetcmout$par$inpshift, vB = 0.05, twotcmstart = 1)
```


### Parameters

```{r SIME par, results = "asis"}
pandoc.table(SIMEout$par, digits=3)
```


\newpage

### Plot

The output object can be used to visualise the model fit:

```{r SIME plotfit, fig.cap='SIME Plot Fit Check', warning=F}
plot_SIMEfit(SIMEout)
```


### Output structure:

Included in the output are all the parameters, the parameters used for the fitting functions, the fits themselves and the raw data.

```{r SIME str, results = "asis"}
pandoc.table(summary(SIMEout))
```

Alternatively, this model can be implemented in a faster manner of sequentially refining its results:

```{r SIME_alt, eval=F}
# Precision of 1
Vndgrid <- seq(from=0, to=4, by=1)
SIMEout1 <-  SIME(t_tac, tacdf, input, Vndgrid, weights = weights, 
    inpshift = onetcmout$par$inpshift)

# Precision of 0.1
Vndgrid <- seq(from=SIMEout1$par$Vnd-1, to=SIMEout1$par$Vnd+1, by=0.1)
SIMEout2 <-  SIME(t_tac, tacdf, input, Vndgrid, weights = weights, 
    inpshift = onetcmout$par$inpshift)

# Precision of 0.05
Vndgrid <- seq(from=SIMEout2$par$Vnd-0.2, to=SIMEout2$par$Vnd+0.2, by=0.05)
SIMEout3 <-  SIME(t_tac, tacdf, input, Vndgrid, weights = weights, 
    inpshift = onetcmout$par$inpshift)
```